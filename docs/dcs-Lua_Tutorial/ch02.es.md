# CapÃ­tulo 02 â€” Pipeline, configuraciÃ³n y librerÃ­as comunes de Lua en DCS (VS Code)

ğŸ‡¬ğŸ‡§ [English](ch02.md) | ğŸ‡ªğŸ‡¸ **EspaÃ±ol** | ğŸ‡¸ğŸ‡ª [Svenska](ch02.sv.md) | ğŸ‡«ğŸ‡® [Suomi](ch02.fi.md)

Volver al Ã­ndice: [README.es.md](README.es.md)

## Objetivo

Montar un workflow (â€œpipelineâ€) prÃ¡ctico para trabajar cÃ³modo con scripting de misiones en DCS usando **Visual Studio Code**, y entender las librerÃ­as/ecosistemas mÃ¡s habituales de Lua en DCS.

Este capÃ­tulo sigue siendo **nivel principiante**. El resultado principal es: â€œsÃ© cÃ³mo voy a trabajarâ€ y â€œsÃ© comprobar en DCS que mi script estÃ¡ corriendoâ€.

## Objetivos del capÃ­tulo

- Entender dÃ³nde se ejecuta Lua en DCS (MSE) y desde quÃ© acciones se lanza.
- Montar un pipeline estable: escribir â†’ meter en la misiÃ³n â†’ ejecutar â†’ observar â†’ iterar.
- Saber â€œver resultadosâ€ sin depender de `print` (pantalla + logs).
- Empezar con una estructura de script limpia: `local` + un solo namespace para tu misiÃ³n.
- Salir con un miniâ€‘lab aplicable en una misiÃ³n real (sin frameworks).

## Ãndice rÃ¡pido

- [Aplicado a DCS (lo mÃ­nimo imprescindible)](#aplicado-a-dcs)
- [Pipeline (autor â†’ empaquetar â†’ ejecutar â†’ observar â†’ iterar)](#pipeline)
- [DO SCRIPT vs DO SCRIPT FILE (quÃ© usar y cuÃ¡ndo)](#do-script-vs-do-script-file)
- [Ver resultados: pantalla y logs](#ver-resultados)
- [Estructura recomendada: `local` + namespace](#namespace)
- [VS Code (setup rÃ¡pido)](#vscode)
- [API de DCS vs librerÃ­as de la comunidad](#api-vs-libs)
- [Miniâ€‘lab (20â€“30 min)](#mini-lab)
- [Checklist: â€œmi pipeline estÃ¡ listoâ€](#checklist)

<a id="aplicado-a-dcs"></a>
## Aplicado a DCS (lo mÃ­nimo imprescindible)

En DCS, el scripting de misiÃ³n corre en el **Mission Scripting Environment (MSE)**: la â€œcapaâ€ donde vive la lÃ³gica de la misiÃ³n (eventos, unidades, acciones, estado).

Â¿CÃ³mo lo ejecutas normalmente?
- **Triggers** del Mission Editor: `DO SCRIPT` / `DO SCRIPT FILE` (lo mÃ¡s comÃºn).
- **AI Tasking**: acciones tipo *Script* / *Script File* (Ãºtil para ejecutar lÃ³gica â€œcomo tareaâ€ de una unidad).
- **Initialization script**: lÃ³gica que se ejecuta muy pronto (antes de que spawneen unidades y antes del primer trigger), segÃºn el tipo de misiÃ³n/servidor.

Nota importante: por **seguridad**, el entorno suele estar â€œsanitizadoâ€; algunas librerÃ­as estÃ¡ndar de Lua (como `io`, `os`, `lfs`) pueden estar deshabilitadas o restringidas. TÃ³malo como una advertencia: diseÃ±a tu misiÃ³n para funcionar sin depender de I/O externo.

<a id="pipeline"></a>
## El pipeline (autor â†’ empaquetar â†’ ejecutar â†’ observar â†’ iterar)

Piensa en el scripting como un bucle:

1. **AutorÃ­a**: escribir/editar en VS Code (feedback rÃ¡pido, bÃºsqueda, control de versiones).
2. **Empaquetado**: incluir scripts (y librerÃ­as) en la misiÃ³n que vas a ejecutar.
3. **EjecuciÃ³n**: lanzar la misiÃ³n en DCS.
4. **ObservaciÃ³n**: confirmar que los cambios se notan (mensajes, comportamiento, logs).
5. **IteraciÃ³n**: ajustar una cosa cada vez hasta que haga lo que quieres.

El error tÃ­pico es intentar â€œterminar toda la lÃ³gicaâ€ antes de tener un bucle fiable. Primero construye el bucle.

Aplicado a DCS (mÃ­nimo viable):
- Crea un trigger *MISSION START* con `DO SCRIPT` y un `trigger.action.outText(...)` para verificar ejecuciÃ³n.
- En cuanto funcione, pÃ¡salo a `DO SCRIPT FILE` y edÃ­talo desde VS Code.

<a id="do-script-vs-do-script-file"></a>
## DO SCRIPT vs DO SCRIPT FILE (quÃ© usar y cuÃ¡ndo)

En el Mission Editor, ambos ejecutan Lua, pero sirven para cosas distintas:

- `DO SCRIPT`: para pruebas rÃ¡pidas o scripts cortos. Ãštil para validar una idea (â€œÂ¿se ejecuta?â€) sin gestionar archivos.
- `DO SCRIPT FILE`: para trabajo real. Te deja versionar, editar en VS Code, reutilizar y mantener scripts sin copiar/pegar.

Aplicado a DCS:
- Para un proyecto serio, usa **un `DO SCRIPT FILE` en *Mission Start*** que cargue tu â€œnÃºcleoâ€ (handlers, menÃºs, estado).
- Usa `DO SCRIPT` solo como â€œsondaâ€ o para cambios muy pequeÃ±os mientras iteras.

<a id="ver-resultados"></a>
## Ver resultados: pantalla y logs

En DCS, â€œverâ€ resultados rÃ¡pido es clave. `print()` a menudo no es lo mÃ¡s Ãºtil; prioriza **feedback visible** y **logs**.

### Ejemplo 1 â€” feedback visual en misiÃ³n (pantalla)

Ãšsalo para confirmar que el trigger realmente se disparÃ³ y que tu script corre.

DÃ³nde pegarlo: Mission Editor â†’ *Triggers* â†’ (por ejemplo *MISSION START*) â†’ `DO SCRIPT`.

```lua
trigger.action.outText("Lua OK: script ejecutado", 10)
```

### Ejemplo 2 â€” logs para depurar (dcs.log)

Ãšsalo para dejar â€œhuellasâ€ cuando el resultado no es visible (o para trazar estados).

DÃ³nde pegarlo: Mission Editor â†’ *Triggers* â†’ (por ejemplo *MISSION START*) â†’ `DO SCRIPT` o dentro de tu archivo `DO SCRIPT FILE`.

```lua
env.info("[MyMission] init: script loaded")
```

DÃ³nde se ve: en el archivo `dcs.log` (normalmente bajo `Saved Games\\DCS\\Logs\\dcs.log`; en servidor dedicado, en los logs del servidor).

<a id="namespace"></a>
## Estructura recomendada: `local` + namespace (sin globales sueltas)

En misiones reales vas a tener varias funciones, estado y callbacks (menÃºs F10, handlers de eventos). Si dejas variables globales â€œsueltasâ€, acabas con colisiones, confusiÃ³n y resets inesperados.

PatrÃ³n recomendado (principiante y prÃ¡ctico): **un Ãºnico namespace global** (por ejemplo `MyMission`) y el resto `local`.

DÃ³nde pegarlo: idealmente en un archivo y cargarlo con `DO SCRIPT FILE` en *Mission Start*.

```lua
MyMission = MyMission or {}
local M = MyMission

M.state = M.state or { kills = 0 }

local function say(text)
  trigger.action.outText(text, 10)
end

function M.init()
  say("MyMission listo")
  env.info("[MyMission] init")
end

M.init()
```

Aplicado a DCS:
- Si luego quieres que otros triggers llamen cosas, puedes hacer `DO SCRIPT` con `MyMission.init()` o `MyMission.state...`.
- Si no necesitas â€œAPI pÃºblicaâ€, mantÃ©n casi todo `local` y expÃ³n solo 2â€“3 funciones en `MyMission`.

## QuÃ© hay que â€œinstalarâ€ (y quÃ© no)

### Para ejecutar Lua en DCS

Normalmente **no** necesitas instalar Lua para *ejecutar* scripts en DCS.

DCS ejecuta el scripting de misiÃ³n con su propio runtime de Lua integrado cuando usas triggers del Editor de Misiones (por ejemplo `DO SCRIPT` / `DO SCRIPT FILE`).

### Para trabajar cÃ³modo (tooling local opcional)

El tooling local es para **escribir mejor**, no para ejecutar dentro de DCS:

- **VS Code + language server de Lua**: diagnÃ³sticos, autocompletado, navegaciÃ³n.
- **Formateador** (opcional): estilo consistente para que los diffs sean legibles.
- **IntÃ©rprete de Lua** (opcional): pequeÃ±as pruebas offline.

Si instalas Lua localmente, Ãºsalo como â€œmodo prÃ¡cticaâ€. DCS sigue ejecutando en su propio entorno, asÃ­ que verifica siempre en el juego.

<a id="vscode"></a>
## Setup de VS Code (prÃ¡ctico)

### 1) Instala una extensiÃ³n de Lua / language server

En VS Code, busca una extensiÃ³n que ofrezca:

- Resaltado de sintaxis
- DiagnÃ³sticos
- Autocompletado (funcionalidad de language server)

Busca soporte de â€œLua Language Serverâ€. Hay varias opciones; lo importante es que tenga language server.

RecomendaciÃ³n (la opciÃ³n mÃ¡s usada): instala **â€œLuaâ€** basada en **Lua Language Server** (servidor `sumneko.lua`).

### 2) Elige una estructura de carpetas simple

Ejemplo:

- `scripts/` â€” tu cÃ³digo de misiÃ³n
- `libs/` â€” librerÃ­as de terceros (MIST/MOOSE/etc.)
- `missions/` â€” la `.miz` que ejecutas (o notas de quÃ© misiÃ³n editas)
- `notes/` â€” notas, TODOs, checklists

La misiÃ³n es tu â€œcontenedor de runtimeâ€; la carpeta es tu â€œfuente de verdadâ€.

### 3) Estrategia de formato (aburrida y consistente)

Elige un estilo de indentaciÃ³n y mantÃ©nlo. El objetivo no es â€œbonitoâ€, es:

- Diffs claros
- Menos errores â€œinvisiblesâ€
- Mejor colaboraciÃ³n

Si usas un formateador, intenta no mezclar â€œsolo formatoâ€ con cambios de lÃ³gica en el mismo commit/ediciÃ³n.

Aplicado a DCS (recomendaciÃ³n simple):
- Trata tu carpeta `scripts/` como â€œfuente de verdadâ€.
- En la misiÃ³n, usa `DO SCRIPT FILE` apuntando a un archivo (por ejemplo `scripts/my_mission.lua`) incluido en la `.miz`.

<a id="api-vs-libs"></a>
## API de DCS vs librerÃ­as de la comunidad

Hay dos â€œmundosâ€:

### DCS: scripting integrado

Es el entorno que existe dentro de las misiones y aporta los bloques bÃ¡sicos:

- Eventos (cosas que pasan)
- Timers / chequeos periÃ³dicos
- MensajerÃ­a
- Acceso a objetos de misiÃ³n (unidades, grupos, coaliciones, zonas) segÃºn lo que exponga DCS

### LibrerÃ­as / frameworks de la comunidad

Paquetes Lua de terceros para no reescribir patrones comunes y construir lÃ³gica compleja mÃ¡s rÃ¡pido.

Suelen aportar:

- Abstracciones de mÃ¡s alto nivel (tasking, spawning, gestiÃ³n de IA)
- Utilidades (buscar unidades, estado, scheduling)
- Sistemas reutilizables (logÃ­stica, IADS, scoring)

## LibrerÃ­as/frameworks comunes en DCS (visiÃ³n conceptual)

### MIST (Mission Scripting Tools)

Suele usarse como capa de utilidades:

- Funciones Ãºtiles y patrones comunes
- Ãštil si quieres estar cerca de â€œLua normalâ€ sin tanto boilerplate

### MOOSE (Mission Object Oriented Scripting Environment)

MÃ¡s orientado a framework:

- Ayuda a estructurar misiones grandes con muchas piezas
- Ãštil si quieres conceptos de alto nivel y lÃ³gica reutilizable

### Otros add-ons (categorÃ­as)

SegÃºn el tipo de misiÃ³n, verÃ¡s:

- **Sistemas IADS** (defensa aÃ©rea integrada)
- **LogÃ­stica / transporte de tropas**
- **Herramientas de admin** para multiplayer (mensajes, utilidades)

Ãšsalos cuando tu pipeline sea estable.

## CuÃ¡ndo usar triggers vs Lua vs librerÃ­as

HeurÃ­stica:

- Comportamiento simple/estÃ¡tico: **triggers del Editor** suelen bastar.
- Flujo dinÃ¡mico, estado, bifurcaciones, chequeos repetidos: **Lua** ayuda.
- Escenario complejo con muchos sistemas: **librerÃ­as/frameworks** ahorran tiempo, pero aÃ±aden dependencias y mantenimiento.

<a id="mini-lab"></a>
## Miniâ€‘lab (20â€“30 min): â€œHello + Debug + F10â€

Objetivo: salir con una misiÃ³n donde confirmas ejecuciÃ³n por pantalla y por log, y tienes un â€œbotÃ³nâ€ F10 para comprobar estado.

1) Crea una misiÃ³n simple en el Mission Editor (un aviÃ³n jugador en pista basta).
2) Crea un archivo `my_mission.lua` (en tu repo/carpeta de trabajo).
3) Dentro de `my_mission.lua`, usa el patrÃ³n de namespace `MyMission` del apartado anterior y aÃ±ade:
   - Un `trigger.action.outText("Lua OK...", 10)` al init.
   - Un `env.info("[MyMission] ...")` al init.
   - Un menÃº F10 con un comando â€œEstadoâ€.
4) En el Mission Editor: *Triggers* â†’ *MISSION START* â†’ `DO SCRIPT FILE` y selecciona tu `my_mission.lua` (incluido en la `.miz`).
5) Ejecuta la misiÃ³n y confirma los resultados.

Snippet mÃ­nimo (ponlo dentro de `M.init()` en tu `my_mission.lua`):

```lua
local menu = missionCommands.addSubMenu("Entrenamiento")
missionCommands.addCommand("Estado", menu, function()
  trigger.action.outText("Kills: " .. M.state.kills, 5)
end)
```

Checklist (en juego / en logs):
- En pantalla ves â€œLua OKâ€¦â€ al empezar la misiÃ³n.
- En `dcs.log` aparece una lÃ­nea con `[MyMission] init`.
- En F10 aparece tu menÃº y el comando â€œEstadoâ€ muestra un texto (aunque sea bÃ¡sico).

Si esto funciona, tu pipeline ya estÃ¡ â€œvivoâ€: ya puedes empezar a aÃ±adir lÃ³gica real (handlers, timers, activaciÃ³n de grupos) sin ir a ciegas.

<a id="checklist"></a>
## Checklist: â€œmi pipeline estÃ¡ listoâ€

- [ ] Tengo VS Code instalado y una extensiÃ³n con Lua language server activa.
- [ ] Tengo estructura de carpetas (`scripts/`, `libs/`, etc.) y encuentro rÃ¡pido los archivos.
- [ ] SÃ© cÃ³mo voy a incluir scripts en una misiÃ³n (`DO SCRIPT` / `DO SCRIPT FILE`).
- [ ] Tengo un plan para verificar cambios (mensajes/logs/comportamiento observable).
- [ ] SÃ© quÃ© quiero explorar despuÃ©s (Lua â€œvanillaâ€, MIST, o MOOSE).

## Siguiente

En el prÃ³ximo capÃ­tulo escribiremos los scripts mÃ­nimos Ãºtiles y construiremos un bucle fiable de â€œcambio â†’ ejecutar â†’ verificarâ€ con el mÃ­nimo de cÃ³digo.

## NavegaciÃ³n

Anterior: [CapÃ­tulo 01](ch01.es.md)
