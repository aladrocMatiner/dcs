# CapÃ­tulo 01 â€” DCS + Lua: para quÃ© sirve el scripting (conceptual)

ğŸ‡¬ğŸ‡§ [English](ch01.md) | ğŸ‡ªğŸ‡¸ **EspaÃ±ol** | ğŸ‡¸ğŸ‡ª [Svenska](ch01.sv.md) | ğŸ‡«ğŸ‡® [Suomi](ch01.fi.md)

Volver al Ã­ndice: [README.es.md](README.es.md)

## Objetivo

Entender quÃ© es el scripting de misiones en DCS, por quÃ© DCS usa Lua y quÃ© problemas puedes resolver con scripting â€” con **snippets mÃ­nimos** para que veas cÃ³mo se conecta con casos reales.

## QuÃ© es DCS (a alto nivel)

DCS es un simulador de combate donde la mayorÃ­a de experiencias se empaquetan como **misiones**:

- Una misiÃ³n define el estado del mundo: mapa, hora, meteorologÃ­a, unidades, waypoints, triggers y reglas.
- Las misiones pueden ser â€œtrainingâ€, â€œinstant actionâ€, â€œcampaignâ€, escenarios multijugador, etc.

El Editor de Misiones tiene herramientas â€œsin cÃ³digoâ€ (triggers, flags, condiciones), y el **scripting en Lua** estÃ¡ al lado cuando necesitas mÃ¡s flexibilidad.

## QuÃ© significa â€œscriptingâ€

Scripting es **describir comportamiento**: â€œcuando pase esto, haz aquelloâ€.

No es lo mismo que:

- **Programar aviÃ³nica** (cÃ³mo estÃ¡n implementados los sistemas del aviÃ³n)
- **Mods** (cambiar assets, cabinas, texturas, modelos de vuelo)

El scripting de misiÃ³n va sobre todo de la *lÃ³gica del escenario*.

## Por quÃ© DCS usa Lua (conceptual)

DCS usa Lua para scripting porque:

- Es **embebible**: un motor de juego lo puede ejecutar dentro de sus sistemas.
- Es **ligero**: carga rÃ¡pido, sintaxis simple, fÃ¡cil de distribuir con misiones.
- Es **flexible**: encaja bien con lÃ³gica de â€œeventos + reglas + estadoâ€.

No necesitas ser ingeniero de software para sacarle partido. Piensa en Lua como una forma de pasar de misiones â€œestÃ¡ticasâ€ a misiones â€œreactivasâ€.

## QuÃ© se puede hacer con scripting Lua en DCS (ejemplos conceptuales)

Los ejemplos de abajo son **conceptuales** â€” en la prÃ¡ctica puedes hacerlo con triggers del Editor, con Lua, o mezclando ambos.

### 1) Entrenamiento y enseÃ±anza

- Mostrar cues paso a paso (â€œAhora ajusta Xâ€, â€œBienâ€, â€œIntÃ©ntalo otra vezâ€).
- Lecciones adaptativas: si el alumno va demasiado rÃ¡pido/lento/alto, dar feedback especÃ­fico.
- PrÃ¡cticas repetibles (por ejemplo, â€œ3 intentosâ€, evaluaciones temporizadas, puntuaciÃ³n).

### 2) Reaccionar a eventos para mover la historia

- Cuando una unidad despega/aterriza: actualizar objetivos o desbloquear la siguiente fase.
- Cuando se destruye un objetivo: disparar una nueva tarea, activar refuerzos, cambiar mensajes.
- Al entrar en una zona: empezar un temporizador, marcar un checkpoint o iniciar una emboscada.

### 3) Flujo y progresiÃ³n (estado/flags)

Lua ayuda cuando quieres que la misiÃ³n se comporte como una **mÃ¡quina de estados**:

- Fase 1 â†’ Fase 2 â†’ Fase 3, segÃºn lo que ocurra de verdad.
- PuntuaciÃ³n, condiciones de fallo, Ã©xito parcial y rutas alternativas.
- SensaciÃ³n de â€œprogresoâ€ dentro de una misma sesiÃ³n.

### 4) Control de IA y grupos (alto nivel)

- Activar grupos solo cuando haga falta (rendimiento y ritmo).
- Crear/activar amenazas de forma progresiva.
- Empujar tareas dinÃ¡micamente (patrullas, interceptaciones, escoltas).

### 5) Tiempo, temporizadores y ritmo

- Disparar eventos tras retrasos (â€œsi sigue vivo tras 5 minutosâ€¦â€).
- Chequeos periÃ³dicos (â€œcada 10 segundos, evaluar condicionesâ€).
- Escalado por oleadas, ventanas de recuperaciÃ³n y objetivos con lÃ­mite de tiempo.

### 6) ComunicaciÃ³n e inmersiÃ³n

- Briefing dinÃ¡mico durante la misiÃ³n.
- Mensajes con contexto (â€œRTBâ€, â€œdivertâ€, â€œamenaza detectadaâ€) segÃºn lo que pasa.
- Flujo tipo â€œradioâ€ con mensajes temporizados y condiciones.

### 7) Cabinas fÃ­sicas y multiâ€‘monitor (Lua, pero no scripting de misiÃ³n)

En DCS tambiÃ©n hay Lua fuera de la â€œlÃ³gica de misiÃ³nâ€. Para cabinas fÃ­sicas y configuraciones multiâ€‘monitor, Lua suele aparecer en:

- **ConfiguraciÃ³n de monitores** (archivos Lua de monitor setup) para colocar viewports exportados en otras pantallas.
- **ExportaciÃ³n de instrumentos/pantallas** (depende del aviÃ³n): muchos mÃ³dulos permiten exportar MFDs y otros repetidores; **algunos mÃ³dulos pueden ofrecer viewports del HUD u otras pantallas**, pero no es algo universal.
- **IntegraciÃ³n de export** (por ejemplo `Export.lua`) para enviar datos a apps/hardware externos (Helios, paneles USB/Arduino, dashboards propios).

Ejemplo prÃ¡ctico (conceptual): montar dos pantallas donde la principal es la vista exterior y una segunda muestra pantallas exportadas de cabina (por ejemplo MFDs/RWR) y mensajes de entrenamiento, mejorando la legibilidad y acercando la experiencia a una cabina fÃ­sica.

## Lua en DCS: dÃ³nde corre y cÃ³mo se usa

En DCS, Lua se usa sobre todo en el **Mission Scripting Environment (MSE)**: el â€œentornoâ€ donde corre la lÃ³gica de misiÃ³n.

- Lo mÃ¡s comÃºn es lanzarlo desde el **Editor de Misiones**, con *triggers* del tipo `DO SCRIPT` y `DO SCRIPT FILE`.
- TambiÃ©n lo verÃ¡s como â€œscript de inicioâ€ (por ejemplo en *Mission Start*), para registrar handlers, crear menÃºs F10 o inicializar estado.
- El MSE no es â€œLua libreâ€: es un entorno controlado con una API de DCS (unidades, eventos, acciones, etc.) y limitaciones pensadas para seguridad/estabilidad.
- Conceptualmente, esto es distinto de `Export.lua`: **Export** corre en el cliente (fuera de la misiÃ³n) para exportar datos a hardware/apps; aquÃ­ solo nos interesa como idea, no como herramienta del CapÃ­tulo 1.

El workflow prÃ¡ctico lo cubrimos en el CapÃ­tulo 02. De momento, la idea clave es:

- El scripting vive en la **capa de lÃ³gica de misiÃ³n**.
- Iteras asÃ­: cambio â†’ ejecuto â†’ observo â†’ ajusto.

## Casos prÃ¡cticos (nivel inicial)

La meta aquÃ­ no es â€œaprender toda la APIâ€, sino reconocer patrones reales que verÃ¡s en misiones y servidores.

### A) Event handler + mensajes (registrar kills y mostrar un â€œscoreâ€)

Un patrÃ³n muy tÃ­pico es escuchar eventos del mundo (despegues, aterrizajes, impactos, killsâ€¦) y reaccionar con lÃ³gica propia.
Esto sirve para entrenamiento, evaluaciÃ³n, â€œscoreboardâ€ y telemetrÃ­a simple dentro de la misiÃ³n.

```lua
local score = { kills = 0 }

world.addEventHandler({
  onEvent = function(self, event)
    if event.id == world.event.S_EVENT_KILL then
      score.kills = score.kills + 1
      trigger.action.outText("Kills: " .. score.kills, 5)
    end
  end
})
```

QuÃ© aprendes aquÃ­: **modelo â€œevento â†’ lÃ³gica â†’ feedbackâ€** (y que todo empieza por demostrar que se ejecuta).

### B) MenÃº F10 simple (botones de misiÃ³n)

El menÃº F10 es la â€œUI rÃ¡pidaâ€ de muchas misiones: reset de entrenamiento, spawn de blancos, pedir info, marcar humo, etc.
Es ideal para pilotos/instructores porque evita â€œrecompilarâ€ triggers complejos para acciones manuales.

```lua
local menu = missionCommands.addSubMenu("Entrenamiento")

missionCommands.addCommand("Mostrar score", menu, function()
  trigger.action.outText("Kills: " .. (score and score.kills or 0), 5)
end)
```

QuÃ© aprendes aquÃ­: **dar control al jugador** con acciones seguras y repetibles.

### C) â€œSpawnâ€ bÃ¡sico sin frameworks (activar grupos preparados)

Sin entrar todavÃ­a en MIST/MOOSE, una forma muy usada de â€œspawnâ€ es preparar grupos en el editor (por ejemplo, **Late Activation**) y activarlos bajo demanda.
Esto es realista y robusto: depende de nombres y de cÃ³mo hayas montado la misiÃ³n, pero es fÃ¡cil de entender.

```lua
local function activateByName(groupName)
  local group = Group.getByName(groupName)
  if group then
    trigger.action.activateGroup(group)
    trigger.action.outText("Activado: " .. groupName, 5)
  else
    trigger.action.outText("No existe el grupo: " .. groupName, 5)
  end
end
```

QuÃ© aprendes aquÃ­: **pipeline â€œpreparo en el editor â†’ activo con Luaâ€** (nombres exactos y control del ritmo).

### D) (Idea) Marcas F10 como â€œcomandosâ€ (admin/entrenamiento)

En servidores de entrenamiento se usa mucho el patrÃ³n â€œpongo una marca con texto y el script hace algoâ€.
No necesitas frameworks para entender la idea: una marca es un *input* del usuario (texto + posiciÃ³n) y tu Lua decide quÃ© hacer.

```lua
world.addEventHandler({
  onEvent = function(self, e)
    if e.id == world.event.S_EVENT_MARK_ADDED and e.text == "smoke" then
      trigger.action.smoke(e.pos, trigger.smokeColor.Red)
      trigger.action.outText("Humo en marca.", 5)
    end
  end
})
```

QuÃ© aprendes aquÃ­: **convertir acciones del jugador en â€œcomandosâ€** (y por quÃ© es Ãºtil para admin/instrucciÃ³n).

## Mini-proyecto guiado (20â€“30 min)

Objetivo: **â€œEntrenamiento con F10: spawn 3 blancos + reset + scoreâ€**.

1) En el Editor, crea 3 grupos de blancos llamados `TGT_01`, `TGT_02`, `TGT_03` y mÃ¡rcalos como **Late Activation**.
2) Crea un trigger *Mission Start* con `DO SCRIPT` (o `DO SCRIPT FILE`) para cargar tu script.
3) AÃ±ade un `score = { kills = 0 }` y un `world.addEventHandler` que incremente kills con `S_EVENT_KILL`.
4) Crea un menÃº F10 â€œEntrenamientoâ€.
5) AÃ±ade comandos `Spawn TGT_01/02/03` que llamen a `activateByName("TGT_01")`, etc.
6) AÃ±ade un comando `Mostrar score` que haga `trigger.action.outText(...)`.
7) AÃ±ade un comando `Reset` que (por ahora) solo reinicie `score.kills = 0` y muestre un mensaje.
8) Prueba: entra en la misiÃ³n, usa F10 para activar blancos, destruye uno y confirma que el contador sube.

Checklist (en juego):
- Aparece el menÃº F10 â€œEntrenamientoâ€.
- Al usar â€œSpawn TGT_01/02/03â€ aparece el mensaje â€œActivadoâ€¦â€.
- Tras destruir un blanco, sale un mensaje con `Kills: X`.
- â€œResetâ€ vuelve el contador a 0.

## Mentalidad de depuraciÃ³n (sin herramientas todavÃ­a)

La mayorÃ­a de problemas no son â€œbugs complicadosâ€; normalmente son:

- Un trigger no se ejecutÃ³.
- Un nombre no coincide (typo en nombre de grupo/zona/unidad).
- El orden de eventos no fue el que esperabas.

Primer hÃ¡bito: **demostrar que tu lÃ³gica se ejecutÃ³** (y luego afinar el comportamiento).

## Errores comunes (y cÃ³mo pensar en ellos)

- **No pasa nada**: asume que el trigger no se disparÃ³.
- **Unidad/grupo incorrecto**: los nombres deben coincidir exactos.
- **Intentar hacerlo todo a la vez**: reduce a un comportamiento y luego amplÃ­a.
- **Mezclar responsabilidades**: separa mentalmente â€œdetectarâ€ de â€œactuarâ€.

## Integraciones avanzadas (mÃ¡s adelante)

- **Persistencia / integraciones fuera de la misiÃ³n**: guardar estado o hablar con sistemas externos suele implicar I/O, y en DCS estÃ¡ **restringido por seguridad**; tocar `MissionScripting.lua` para desâ€‘sanitizar es delicado y conlleva riesgo si no controlas el cÃ³digo que ejecutas.
- **SRS / ATIS / TTS**: muchas comunidades conectan lÃ³gica de misiÃ³n con voz y automatizaciones (lo veremos como â€œecosistemaâ€, no como requisito).
- **`Export.lua`**: Ãºtil para cabinas fÃ­sicas, telemetrÃ­a y apps externas; es otra capa distinta al MSE.

## Siguiente

El CapÃ­tulo 02 cubre:

- Un â€œpipelineâ€ para trabajar cÃ³modo (VS Code).
- QuÃ© hace falta (y quÃ© no) instalar para usar Lua con DCS.
- QuÃ© librerÃ­as comunes existen (MIST/MOOSE y otras) y cuÃ¡ndo ayudan.

## NavegaciÃ³n

Siguiente: [CapÃ­tulo 02](ch02.es.md)
